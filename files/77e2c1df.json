{"order":["5a7b9464","29ff852a","55658385","1733bba3","817ba033","746cd426","811fac69","ec1bcd1f","6cfc058a","1073881e","4650b8ac","20debc11","edc8b750","e404bdc4","9649f2dc","e06f6785"],"armyData":{"55658385":{"name":"Death Guard Cultists","factionKeywords":["Death Guard","Nurgle","Chaos"],"keywords":["Infantry","Cultists","Plague Followers"],"abilities":{},"models":{"models":{"70cd14d168220aad":{"name":"Death Guard Cultist Champion","abilities":[],"weapons":[{"name":"Autogun","number":1}],"number":1,"node":{}},"332f019233f13ccf":{"name":"Death Guard Cultist w/ Autogun","abilities":[],"weapons":[{"name":"Autogun","number":1}],"number":9,"node":{}}},"totalNumberOfModels":10},"modelProfiles":{"Death Guard Cultist":{"name":"Death Guard Cultist","m":"6\"","ws":"4+","bs":"4+","s":"3","t":"3","w":"1","a":"1","ld":"5","sv":"6+"},"Death Guard Cultist Champion":{"name":"Death Guard Cultist Champion","m":"6\"","ws":"4+","bs":"4+","s":"3","t":"3","w":"1","a":"2","ld":"6","sv":"6+"}},"weapons":{"Autogun":{"name":"Autogun","range":"24\"","type":"Rapid Fire 1","s":"3","ap":"0","d":"1","abilities":"-"}},"rules":[],"uuid":"55658385","unassignedWeapons":[],"pl":2,"isSingleModel":false},"5a7b9464":{"name":"Death Guard Daemon Prince","factionKeywords":["Heretic Astartes","Death Guard","Nurgle","Chaos","Inexorable"],"keywords":["Character","Daemon","Monster","Daemon Prince","Psyker","Bubonic Astartes","Inexorable Warlord"],"abilities":{"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Lord of the Death Guard (Aura)":{"name":"Lord of the Death Guard (Aura)","desc":"While a friendly ＜PLAGUE COMPANY＞ CORE unit is within 6\\\" of this model, each time a model in that unit makes an attack, re-roll a hit roll of 1."},"Rotten Constitution":{"name":"Rotten Constitution","desc":"- Add 1 to the Toughness characteristic of this WARLORD.\n- Each time an attack with an Armour Penetration characteristic of -1 or -2 is allocated to this WARLORD, that attack has an Armour Penetration chracteristic of 0 instead."}},"models":{"models":{"785391b6fbfa6697":{"name":"Death Guard Daemon Prince","abilities":["Rotten Constitution","Daemonic","Disgustingly Resilient","Lord of the Death Guard (Aura)","Contagions of Nurgle","Inexorable Advance"],"weapons":[{"name":"Malefic talons","number":1},{"name":"Hellforged sword","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Death Guard Daemon Prince":{"name":"Death Guard Daemon Prince","m":"8\"","ws":"2+","bs":"2+","s":"7","t":"6","w":"8","a":"6","ld":"10","sv":"3+"}},"weapons":{"Malefic talons":{"name":"Malefic talons","range":"Melee","type":"Melee","s":"User","ap":"-1","d":"2","abilities":"Each time this model fights, it makes 1 additional attack with this weapon."},"Hellforged sword":{"name":"Hellforged sword","range":"Melee","type":"Melee","s":"+1","ap":"-3","d":"3","abilities":"-"}},"rules":["Contagions of Nurgle","Inexorable Advance"],"uuid":"5a7b9464","unassignedWeapons":[],"pl":8,"isSingleModel":true,"psykerProfiles":[{"name":"Death Guard Daemon Prince","cast":"1","deny":"1","known":"Smite and 1 power from the Contagion discipline","other":"-"}],"powersKnown":[{"name":"Smite","warpCharge":"5","range":"18\"","details":"Smite has a warp charge value of 5. If manifested, the closest visible enemy unit within 18\" of the psyker suffers D3 mortal wounds (pg 181). If the result of the Psychic test was more than 10 the target suffers D6 mortal wounds instead."},{"name":"Putrescent Vitality","warpCharge":"7","range":"18\"","details":"Blessing: If manifested, select one friendly DEATH GUARD INFANTRY unit within 18\" of this PSYKER. Until the start of your next Psychic phase, add 1 to the Strength and Toughness characteristics of models in that unit."}]},"29ff852a":{"name":"Malignant Plaguecaster","factionKeywords":["Death Guard","Heretic Astartes","Nurgle","Chaos","Inexorable"],"keywords":["Character","Infantry","Psyker","Bubonic Astartes","Malignant Plaguecaster","Inexorable Warlord"],"abilities":{"Pestilential Fallout":{"name":"Pestilential Fallout","desc":"Each time this model successfully manifests a psychic power, if the result of the Psychic test was 7 or more, the closest enemy unit within 12\\\" suffers one mortal wound."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Plague Skull of Glothila":{"name":"Plague Skull of Glothila","desc":"Once per battle, at the end of your Movement phase, the bearer can use this Relic. If it does, select one enemy unit within 6\\\" of the bearer and roll seven D6s; for each 4-5, that unit suffers 1 mortal wound; for each 6, that unit suffers D3 mortal wounds."}},"models":{"models":{"643a32177e650371":{"name":"Malignant Plaguecaster","abilities":["Plague Skull of Glothila","Pestilential Fallout","Disgustingly Resilient","Contagions of Nurgle","Inexorable Advance"],"weapons":[{"name":"Corrupted staff","number":1},{"name":"Blight grenade","number":1},{"name":"Krak grenades","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Malignant Plaguecaster":{"name":"Malignant Plaguecaster","m":"5\"","ws":"3+","bs":"3+","s":"4","t":"5","w":"4","a":"4","ld":"8","sv":"3+"}},"weapons":{"Corrupted staff":{"name":"Corrupted staff","range":"Melee","type":"Melee","s":"+3","ap":"-1","d":"D3","abilities":"Plague Weapon."},"Blight grenade":{"name":"Blight grenade","range":"6\"","type":"Grenade D6","s":"4","ap":"0","d":"1","abilities":"Plague Weapon. Blast."},"Krak grenades":{"name":"Krak grenades","range":"6\"","type":"Grenade 1","s":"6","ap":"-1","d":"D3","abilities":"-"}},"rules":["Contagions of Nurgle","Inexorable Advance"],"uuid":"29ff852a","unassignedWeapons":[],"pl":5,"isSingleModel":true,"psykerProfiles":[{"name":"Malignant Plaguecaster","cast":"2","deny":"1","known":"Smite and 2 powers from the Contagion discipline","other":"-"}],"powersKnown":[{"name":"Smite","warpCharge":"5","range":"18\"","details":"Smite has a warp charge value of 5. If manifested, the closest visible enemy unit within 18\" of the psyker suffers D3 mortal wounds (pg 181). If the result of the Psychic test was more than 10 the target suffers D6 mortal wounds instead."},{"name":"Plague Wind","warpCharge":"6","range":"18\"","details":"Witchfire: If manifested, select one enemy unit within 18\" of and visible to this PSYKER. Roll one D6 for each model in that unit. For each 6, that unit suffers 1 mortal wound. If the result of the Psychic test was 9+, that unit suffers 1 mortal wound for each 5+ instead."},{"name":"Curse of the Leper","warpCharge":"6","range":"18\"","details":"Witchfire: If manifested, select the closest enemy unit that is within 18\" of and visible to this PSYKER. Roll seven D6s: for each dice result that exceeds that enemy unit's Toughness characteristic, it suffers 1 mortal wound."}]},"1733bba3":{"name":"Poxwalkers","factionKeywords":["Nurgle","Death Guard","Chaos","Inexorable"],"keywords":["Infantry","Poxwalkers"],"abilities":{"Curse of the Walking Pox":{"name":"Curse of the Walking Pox","desc":"Each time a melee attack is made by a model in this unit, if an enemy model is destroyed (excluding VEHICLE or MONSTER models), one of this unit's destroyed models is added back to it with 1 wound remaining. Models added back to this unit in this way can be set up within Engagement Range of enemy units that are already within Engagement Range of this unit."},"Fodder":{"name":"Fodder","desc":"Each time a Morale test is taken for this unit, it is automatically passed."},"Mindless Horde":{"name":"Mindless Horde","desc":"This unit cannot perform actions (excluding the Spread the Sickness action)."},"Unending Horde":{"name":"Unending Horde","desc":"Each time a model in this unit would lose a wound, roll one D6; on a 6, that wound is not lost."}},"models":{"models":{"b7cd4c6d952fc589":{"name":"Poxwalker","abilities":["Curse of the Walking Pox","Fodder","Mindless Horde","Unending Horde","Objective Secured","Contagions of Nurgle"],"weapons":[{"name":"Improvised weapon","number":1}],"number":16,"node":{}}},"totalNumberOfModels":16},"modelProfiles":{"Poxwalker":{"name":"Poxwalker","m":"4\"","ws":"4+","bs":"-","s":"3","t":"4","w":"1","a":"2","ld":"4","sv":"7+"}},"weapons":{"Improvised weapon":{"name":"Improvised weapon","range":"Melee","type":"Melee","s":"User","ap":"0","d":"1","abilities":"-"}},"rules":["Objective Secured","Contagions of Nurgle"],"uuid":"1733bba3","unassignedWeapons":[],"pl":5,"isSingleModel":false},"817ba033":{"name":"Poxwalkers","factionKeywords":["Nurgle","Death Guard","Chaos","Inexorable"],"keywords":["Infantry","Poxwalkers"],"abilities":{"Curse of the Walking Pox":{"name":"Curse of the Walking Pox","desc":"Each time a melee attack is made by a model in this unit, if an enemy model is destroyed (excluding VEHICLE or MONSTER models), one of this unit's destroyed models is added back to it with 1 wound remaining. Models added back to this unit in this way can be set up within Engagement Range of enemy units that are already within Engagement Range of this unit."},"Fodder":{"name":"Fodder","desc":"Each time a Morale test is taken for this unit, it is automatically passed."},"Mindless Horde":{"name":"Mindless Horde","desc":"This unit cannot perform actions (excluding the Spread the Sickness action)."},"Unending Horde":{"name":"Unending Horde","desc":"Each time a model in this unit would lose a wound, roll one D6; on a 6, that wound is not lost."}},"models":{"models":{"14d03bb9f171e41e":{"name":"Poxwalker","abilities":["Curse of the Walking Pox","Fodder","Mindless Horde","Unending Horde","Objective Secured","Contagions of Nurgle"],"weapons":[{"name":"Improvised weapon","number":1}],"number":15,"node":{}}},"totalNumberOfModels":15},"modelProfiles":{"Poxwalker":{"name":"Poxwalker","m":"4\"","ws":"4+","bs":"-","s":"3","t":"4","w":"1","a":"2","ld":"4","sv":"7+"}},"weapons":{"Improvised weapon":{"name":"Improvised weapon","range":"Melee","type":"Melee","s":"User","ap":"0","d":"1","abilities":"-"}},"rules":["Objective Secured","Contagions of Nurgle"],"uuid":"817ba033","unassignedWeapons":[],"pl":5,"isSingleModel":false},"746cd426":{"name":"Chaos Contemptor Dreadnought","factionKeywords":["Chaos","Heretic Astartes","Death Guard","Nurgle","Inexorable"],"keywords":["Vehicle","Dreadnought","Core","Relic","Contemptor Dreadnought","Bubonic Astartes"],"abilities":{"Explodes":{"name":"Explodes","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 6 it explodes, and each unit within 3\\\" suffers 1 mortal wound."},"Relentless Hatred":{"name":"Relentless Hatred","desc":"Each time an attack is allocated to this model, subtract 1 from the Damage characteristic of that attack (to a minmum of 1)"},"Atomantic Shielding":{"name":"Atomantic Shielding","desc":"This model has a 5+ invulnerable save."}},"models":{"models":{"a2bc0cbba907e197":{"name":"Chaos Contemptor Dreadnought","abilities":["Explodes","Relentless Hatred","Atomantic Shielding","Hateful Assault","Martial Legacy","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Twin volkite culverin","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Chaos Contemptor Dreadnought":{"name":"Chaos Contemptor Dreadnought","m":"8\"","ws":"3+","bs":"3+","s":"7","t":"7","w":"9","a":"4","ld":"8","sv":"3+"}},"weapons":{"Twin volkite culverin":{"name":"Twin volkite culverin","range":"45\"","type":"Heavy 8","s":"6","ap":"0","d":"2","abilities":"Each time an attack is made with this weapon, an unmodified wound roll of 6 inflicts 1 mortal wound on the target in addition to any normal damage."}},"rules":["Hateful Assault","Martial Legacy","Inexorable Advance","Contagions of Nurgle"],"uuid":"746cd426","unassignedWeapons":[],"pl":8,"isSingleModel":true},"811fac69":{"name":"Chaos Contemptor Dreadnought","factionKeywords":["Chaos","Heretic Astartes","Death Guard","Nurgle","Inexorable"],"keywords":["Vehicle","Dreadnought","Core","Relic","Contemptor Dreadnought","Bubonic Astartes"],"abilities":{"Explodes":{"name":"Explodes","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 6 it explodes, and each unit within 3\\\" suffers 1 mortal wound."},"Relentless Hatred":{"name":"Relentless Hatred","desc":"Each time an attack is allocated to this model, subtract 1 from the Damage characteristic of that attack (to a minmum of 1)"},"Atomantic Shielding":{"name":"Atomantic Shielding","desc":"This model has a 5+ invulnerable save."}},"models":{"models":{"d954e4aff304b667":{"name":"Chaos Contemptor Dreadnought","abilities":["Explodes","Relentless Hatred","Atomantic Shielding","Hateful Assault","Martial Legacy","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Twin volkite culverin","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Chaos Contemptor Dreadnought":{"name":"Chaos Contemptor Dreadnought","m":"8\"","ws":"3+","bs":"3+","s":"7","t":"7","w":"9","a":"4","ld":"8","sv":"3+"}},"weapons":{"Twin volkite culverin":{"name":"Twin volkite culverin","range":"45\"","type":"Heavy 8","s":"6","ap":"0","d":"2","abilities":"Each time an attack is made with this weapon, an unmodified wound roll of 6 inflicts 1 mortal wound on the target in addition to any normal damage."}},"rules":["Hateful Assault","Martial Legacy","Inexorable Advance","Contagions of Nurgle"],"uuid":"811fac69","unassignedWeapons":[],"pl":8,"isSingleModel":true},"ec1bcd1f":{"name":"Deathshroud Terminators","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Infantry","Terminator","Deathshroud Terminators","Bubonic Astartes","Core"],"abilities":{"Bodyguard (Aura)":{"name":"Bodyguard (Aura)","desc":"While a friendly ＜PLAGUE COMPANY＞ CHARACTER unit that has a Wounds characteristic of 9 or less is within 3\\\" of this unit, enemy models cannot target that CHARACTER unit with ranged attacks."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Diseased Terminator Armour":{"name":"Diseased Terminator Armour","desc":"Models in this unit have a 4+ invulnerable save."},"Teleport Strike":{"name":"Teleport Strike","desc":"During deployment, if every model in this unit has this ability, then you can set up this unit in a teleportarium chamber instead of setting it up on the battlefield. If you do, then in the Reinforcements step of one of your Movement phases you can set up this unit anywhere on the battlefield that is more than 9\\\" away from any enemy models."},"Remorseless":{"name":"Remorseless","desc":"Each time a Combat Attrition test is taken for this unit, ignore any or all modifiers."}},"models":{"models":{"dda16339146602a9":{"name":"Deathshroud Champion","abilities":["Bodyguard (Aura)","Disgustingly Resilient","Diseased Terminator Armour","Teleport Strike","Remorseless","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Plaguespurt gauntlet","number":1},{"name":"Manreaper - Cleave","number":1},{"name":"Manreaper - Scythe","number":1}],"number":1,"node":{}},"a6c0a1961bf21203":{"name":"Deathshroud Terminator","abilities":["Bodyguard (Aura)","Disgustingly Resilient","Diseased Terminator Armour","Teleport Strike","Remorseless","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Plaguespurt gauntlet","number":1},{"name":"Manreaper - Cleave","number":1},{"name":"Manreaper - Scythe","number":1}],"number":2,"node":{}}},"totalNumberOfModels":3},"modelProfiles":{"Deathshroud Champion":{"name":"Deathshroud Champion","m":"5\"","ws":"2+","bs":"3+","s":"4","t":"5","w":"3","a":"5","ld":"9","sv":"2+"},"Deathshroud Terminator":{"name":"Deathshroud Terminator","m":"5\"","ws":"2+","bs":"3+","s":"4","t":"5","w":"3","a":"4","ld":"8","sv":"2+"}},"weapons":{"Plaguespurt gauntlet":{"name":"Plaguespurt gauntlet","range":"12\"","type":"Pistol D6","s":"3","ap":"0","d":"1","abilities":"Plague Weapon. Each time an attack is made with this weapon, that attack automatically hits the target."},"Manreaper - Cleave":{"name":"Manreaper - Cleave","range":"Melee","type":"Melee","s":"+3","ap":"-3","d":"2","abilities":"Plague Weapon. Each time an attack is made with this weapon profile, subtract 1 from that attack's hit roll."},"Manreaper - Scythe":{"name":"Manreaper - Scythe","range":"Melee","type":"Melee","s":"+1","ap":"-1","d":"1","abilities":"Plague Weapon. Each time an attack is made with this weapon profile, make 2 hit rolls instead of 1."}},"rules":["Inexorable Advance","Contagions of Nurgle"],"uuid":"ec1bcd1f","unassignedWeapons":[],"pl":7,"isSingleModel":false},"6cfc058a":{"name":"Deathshroud Terminators","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Infantry","Terminator","Deathshroud Terminators","Bubonic Astartes","Core"],"abilities":{"Bodyguard (Aura)":{"name":"Bodyguard (Aura)","desc":"While a friendly ＜PLAGUE COMPANY＞ CHARACTER unit that has a Wounds characteristic of 9 or less is within 3\\\" of this unit, enemy models cannot target that CHARACTER unit with ranged attacks."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Diseased Terminator Armour":{"name":"Diseased Terminator Armour","desc":"Models in this unit have a 4+ invulnerable save."},"Teleport Strike":{"name":"Teleport Strike","desc":"During deployment, if every model in this unit has this ability, then you can set up this unit in a teleportarium chamber instead of setting it up on the battlefield. If you do, then in the Reinforcements step of one of your Movement phases you can set up this unit anywhere on the battlefield that is more than 9\\\" away from any enemy models."},"Remorseless":{"name":"Remorseless","desc":"Each time a Combat Attrition test is taken for this unit, ignore any or all modifiers."}},"models":{"models":{"2a2a3a65d6aa5962":{"name":"Deathshroud Champion","abilities":["Bodyguard (Aura)","Disgustingly Resilient","Diseased Terminator Armour","Teleport Strike","Remorseless","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Plaguespurt gauntlet","number":1},{"name":"Manreaper - Cleave","number":1},{"name":"Manreaper - Scythe","number":1}],"number":1,"node":{}},"4a6fb8d70c545886":{"name":"Deathshroud Terminator","abilities":["Bodyguard (Aura)","Disgustingly Resilient","Diseased Terminator Armour","Teleport Strike","Remorseless","Inexorable Advance","Contagions of Nurgle"],"weapons":[{"name":"Plaguespurt gauntlet","number":1},{"name":"Manreaper - Cleave","number":1},{"name":"Manreaper - Scythe","number":1}],"number":2,"node":{}}},"totalNumberOfModels":3},"modelProfiles":{"Deathshroud Champion":{"name":"Deathshroud Champion","m":"5\"","ws":"2+","bs":"3+","s":"4","t":"5","w":"3","a":"5","ld":"9","sv":"2+"},"Deathshroud Terminator":{"name":"Deathshroud Terminator","m":"5\"","ws":"2+","bs":"3+","s":"4","t":"5","w":"3","a":"4","ld":"8","sv":"2+"}},"weapons":{"Plaguespurt gauntlet":{"name":"Plaguespurt gauntlet","range":"12\"","type":"Pistol D6","s":"3","ap":"0","d":"1","abilities":"Plague Weapon. Each time an attack is made with this weapon, that attack automatically hits the target."},"Manreaper - Cleave":{"name":"Manreaper - Cleave","range":"Melee","type":"Melee","s":"+3","ap":"-3","d":"2","abilities":"Plague Weapon. Each time an attack is made with this weapon profile, subtract 1 from that attack's hit roll."},"Manreaper - Scythe":{"name":"Manreaper - Scythe","range":"Melee","type":"Melee","s":"+1","ap":"-1","d":"1","abilities":"Plague Weapon. Each time an attack is made with this weapon profile, make 2 hit rolls instead of 1."}},"rules":["Inexorable Advance","Contagions of Nurgle"],"uuid":"6cfc058a","unassignedWeapons":[],"pl":7,"isSingleModel":false},"1073881e":{"name":"Foul Blightspawn","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Character","Infantry","Bubonic Astartes","Foetid Virion","Foul Blightspawn"],"abilities":{"Putrefying Stink":{"name":"Putrefying Stink","desc":"At the start of the Fight phase, you can select one enemy unit within 3\\\" of this model. That unit is not eligible to fight this phase until after all eligible units from your army have done so."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Arch-Contaminator (Aura)":{"name":"Arch-Contaminator (Aura)","desc":"While a friendly ＜PLAGUE COMPANY＞ CORE unit is within 6\\\" of this WARLORD:\n- Each time a model in that unit makes a melee attack with a plague weapon, you can re-roll the wound roll.\n- Each time a model in that unit makes a ranged attack with a Plague Weapon that targets a unit within 12\\\", you can re-roll the wound roll."},"Revolting Stench (Aura)":{"name":"Revolting Stench (Aura)","desc":"While an enemy unit is within 6\\\" of the bearer, that unit cannot make use of any rules that allow it to fight first and never counts as having made a charge move this turn, irrespective of any abilities that unit may have."}},"models":{"models":{"c6d0bd36e996a8f4":{"name":"Foul Blightspawn","abilities":["Arch-Contaminator (Aura)","Revolting Stench (Aura)","Putrefying Stink","Disgustingly Resilient","Contagions of Nurgle","Inexorable Advance"],"weapons":[{"name":"Unholy death's head grenade","number":1},{"name":"Plague sprayer","number":1},{"name":"Blight grenade","number":1},{"name":"Krak grenades","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Foul Blightspawn":{"name":"Foul Blightspawn","m":"5\"","ws":"3+","bs":"3+","s":"4","t":"5","w":"4","a":"4","ld":"8","sv":"3+"}},"weapons":{"Unholy death's head grenade":{"name":"Unholy death's head grenade","range":"6\"","type":"Grenade 2D6","s":"5","ap":"-1","d":"1","abilities":"Blast. Plague Weapon. The bearer can only shoot with this weapon once per battle."},"Plague sprayer":{"name":"Plague sprayer","range":"12\"","type":"Assault D6","s":"7","ap":"-3","d":"2","abilities":"Plague Weapon. Each time an attack is made with this weapon, that attack automatically hits the target."},"Blight grenade":{"name":"Blight grenade","range":"6\"","type":"Grenade D6","s":"4","ap":"0","d":"1","abilities":"Plague Weapon. Blast."},"Krak grenades":{"name":"Krak grenades","range":"6\"","type":"Grenade 1","s":"6","ap":"-1","d":"D3","abilities":"-"}},"rules":["Contagions of Nurgle","Inexorable Advance"],"uuid":"1073881e","unassignedWeapons":[],"pl":4,"isSingleModel":true},"4650b8ac":{"name":"Tallyman","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Character","Infantry","Bubonic Astartes","Foetid Virion","Tallyman"],"abilities":{"The Seven-fold Chant":{"name":"The Seven-fold Chant","desc":"At the start of the Command phase, if this model is on the battlefield, roll 2D6, on a 7+ you gain 1 Command point."},"Malicious Calculation":{"name":"Malicious Calculation","desc":"In your Command phase, this model can tally for one friendly ＜PLAGUE COMPANY＞ CORE unit within 6\\\" of it. Until the start of your next Command phase, each time a model in that unit makes an attack, add 1 to that attack's hit roll. Each unit can only be tallied for once per turn."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Tollkeeper (Aura)":{"name":"Tollkeeper (Aura)","desc":"While a friendly ＜PLAGUE COMPANY＞ CORE unit is within 6\\\" of the bearer, each time a model in that unit makes a ranged attack, an unmodified hit roll of 6 scores 1 additional hit."},"Ferric Blight (Contagion)":{"name":"Ferric Blight (Contagion)","desc":"While an enemy unit is within Contagion Range of this unit, each time an attack is made by a friendly INEXORABLE model, improve the Armour Penetration characteristic of that attack by 1."}},"models":{"models":{"21188561f28b99df":{"name":"Tallyman","abilities":["Tollkeeper (Aura)","Ferric Blight (Contagion)","The Seven-fold Chant","Malicious Calculation","Disgustingly Resilient","Contagions of Nurgle","Inexorable Advance"],"weapons":[{"name":"Plasma pistol, Standard","number":1},{"name":"Plasma pistol, Supercharge","number":1},{"name":"Blight grenade","number":1},{"name":"Krak grenades","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Tallyman":{"name":"Tallyman","m":"5\"","ws":"3+","bs":"3+","s":"4","t":"5","w":"4","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plasma pistol, Standard":{"name":"Plasma pistol, Standard","range":"12\"","type":"Pistol 1","s":"7","ap":"-3","d":"1","abilities":"-"},"Plasma pistol, Supercharge":{"name":"Plasma pistol, Supercharge","range":"12\"","type":"Pistol 1","s":"8","ap":"-3","d":"2","abilities":"If any unmodified hit rolls of 1 are made for attacks with this weapon profile, the bearer is destroyed after shooting with this weapon."},"Blight grenade":{"name":"Blight grenade","range":"6\"","type":"Grenade D6","s":"4","ap":"0","d":"1","abilities":"Plague Weapon. Blast."},"Krak grenades":{"name":"Krak grenades","range":"6\"","type":"Grenade 1","s":"6","ap":"-1","d":"D3","abilities":"-"}},"rules":["Contagions of Nurgle","Inexorable Advance"],"uuid":"4650b8ac","unassignedWeapons":[],"pl":4,"isSingleModel":true},"20debc11":{"name":"Foetid Bloat-drone","factionKeywords":["Nurgle","Heretic Astartes","Death Guard","Chaos","Inexorable"],"keywords":["Vehicle","Daemon Engine","Daemon","Fly","Foetid Bloat-drone"],"abilities":{"Putrid Explosion":{"name":"Putrid Explosion","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 4+ it explodes, and each unit (excluding NURGLE units) within 6\\\" suffers 1 mortal wound."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."}},"models":{"models":{"66c85916eff874d4":{"name":"Foetid Bloat-drone","abilities":["Putrid Explosion","Disgustingly Resilient","Daemonic","Contagions of Nurgle"],"weapons":[{"name":"Plague probe","number":1},{"name":"Fleshmower","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Foetid Bloat-drone":{"name":"Foetid Bloat-drone","m":"10\"","ws":"3+","bs":"3+","s":"6","t":"7","w":"9","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plague probe":{"name":"Plague probe","range":"Melee","type":"Melee","s":"User","ap":"-2","d":"1","abilities":"Plague Weapon"},"Fleshmower":{"name":"Fleshmower","range":"Melee","type":"Melee","s":"+1","ap":"-2","d":"2","abilities":"Plague Weapon. Each time an attack is made with this weapon, make 3 hit rolls instead of 1."}},"rules":["Contagions of Nurgle"],"uuid":"20debc11","unassignedWeapons":[],"pl":7,"isSingleModel":true},"edc8b750":{"name":"Foetid Bloat-drone","factionKeywords":["Nurgle","Heretic Astartes","Death Guard","Chaos","Inexorable"],"keywords":["Vehicle","Daemon Engine","Daemon","Fly","Foetid Bloat-drone"],"abilities":{"Putrid Explosion":{"name":"Putrid Explosion","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 4+ it explodes, and each unit (excluding NURGLE units) within 6\\\" suffers 1 mortal wound."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."}},"models":{"models":{"eabc7094da669bc7":{"name":"Foetid Bloat-drone","abilities":["Putrid Explosion","Disgustingly Resilient","Daemonic","Contagions of Nurgle"],"weapons":[{"name":"Plague probe","number":1},{"name":"Fleshmower","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Foetid Bloat-drone":{"name":"Foetid Bloat-drone","m":"10\"","ws":"3+","bs":"3+","s":"6","t":"7","w":"9","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plague probe":{"name":"Plague probe","range":"Melee","type":"Melee","s":"User","ap":"-2","d":"1","abilities":"Plague Weapon"},"Fleshmower":{"name":"Fleshmower","range":"Melee","type":"Melee","s":"+1","ap":"-2","d":"2","abilities":"Plague Weapon. Each time an attack is made with this weapon, make 3 hit rolls instead of 1."}},"rules":["Contagions of Nurgle"],"uuid":"edc8b750","unassignedWeapons":[],"pl":7,"isSingleModel":true},"e404bdc4":{"name":"Plagueburst Crawler","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Daemon","Vehicle","Daemon Engine","Plagueburst Crawler"],"abilities":{"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Explodes":{"name":"Explodes","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 6 it explodes, and each unit within 6\\\" suffers D3 mortal wounds."}},"models":{"models":{"20fc2d6af0f54415":{"name":"Plagueburst Crawler","abilities":["Daemonic","Disgustingly Resilient","Explodes","Contagions of Nurgle"],"weapons":[{"name":"Plagueburst Mortar","number":1},{"name":"Entropy cannon","number":2},{"name":"Heavy slugger","number":1}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Plagueburst Crawler":{"name":"Plagueburst Crawler","m":"*","ws":"6+","bs":"*","s":"*","t":"8","w":"12","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plagueburst Mortar":{"name":"Plagueburst Mortar","range":"48\"","type":"Heavy D6","s":"8","ap":"-2","d":"2","abilities":"Blast. Plague Weapon. This weapon can target units that are not visible to the bearer."},"Entropy cannon":{"name":"Entropy cannon","range":"36\"","type":"Heavy 1","s":"8","ap":"-4","d":"D3+3","abilities":"Plague Weapon"},"Heavy slugger":{"name":"Heavy slugger","range":"36\"","type":"Heavy 4","s":"5","ap":"-1","d":"1","abilities":"-"}},"rules":["Contagions of Nurgle"],"uuid":"e404bdc4","unassignedWeapons":[],"pl":9,"isSingleModel":true,"woundTrack":{"Plagueburst Crawler":{"6+":["9\"","3+","7"],"3-5":["6\"","4+","6"],"1-2":["4\"","5+","5"]}}},"9649f2dc":{"name":"Plagueburst Crawler","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Daemon","Vehicle","Daemon Engine","Plagueburst Crawler"],"abilities":{"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Explodes":{"name":"Explodes","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 6 it explodes, and each unit within 6\\\" suffers D3 mortal wounds."}},"models":{"models":{"b84627757fcd9a07":{"name":"Plagueburst Crawler","abilities":["Daemonic","Disgustingly Resilient","Explodes","Contagions of Nurgle"],"weapons":[{"name":"Plagueburst Mortar","number":1},{"name":"Heavy slugger","number":1},{"name":"Entropy cannon","number":2}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Plagueburst Crawler":{"name":"Plagueburst Crawler","m":"*","ws":"6+","bs":"*","s":"*","t":"8","w":"12","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plagueburst Mortar":{"name":"Plagueburst Mortar","range":"48\"","type":"Heavy D6","s":"8","ap":"-2","d":"2","abilities":"Blast. Plague Weapon. This weapon can target units that are not visible to the bearer."},"Heavy slugger":{"name":"Heavy slugger","range":"36\"","type":"Heavy 4","s":"5","ap":"-1","d":"1","abilities":"-"},"Entropy cannon":{"name":"Entropy cannon","range":"36\"","type":"Heavy 1","s":"8","ap":"-4","d":"D3+3","abilities":"Plague Weapon"}},"rules":["Contagions of Nurgle"],"uuid":"9649f2dc","unassignedWeapons":[],"pl":9,"isSingleModel":true,"woundTrack":{"Plagueburst Crawler":{"6+":["9\"","3+","7"],"3-5":["6\"","4+","6"],"1-2":["4\"","5+","5"]}}},"e06f6785":{"name":"Plagueburst Crawler","factionKeywords":["Chaos","Death Guard","Heretic Astartes","Nurgle","Inexorable"],"keywords":["Daemon","Vehicle","Daemon Engine","Plagueburst Crawler"],"abilities":{"Daemonic":{"name":"Daemonic","desc":"Models in this unit have a 5+ invulnerable save."},"Disgustingly Resilient":{"name":"Disgustingly Resilient","desc":"Each time an attack is allocated to a model in this unit, subtract 1 from the Damage characteristic of that attack (to a minimum of 1)."},"Explodes":{"name":"Explodes","desc":"When this model is destroyed, roll one D6 before removing it from play. On a 6 it explodes, and each unit within 6\\\" suffers D3 mortal wounds."}},"models":{"models":{"805509a6178316e6":{"name":"Plagueburst Crawler","abilities":["Daemonic","Disgustingly Resilient","Explodes","Contagions of Nurgle"],"weapons":[{"name":"Plagueburst Mortar","number":1},{"name":"Heavy slugger","number":1},{"name":"Entropy cannon","number":2}],"number":1,"node":{}}},"totalNumberOfModels":1},"modelProfiles":{"Plagueburst Crawler":{"name":"Plagueburst Crawler","m":"*","ws":"6+","bs":"*","s":"*","t":"8","w":"12","a":"4","ld":"8","sv":"3+"}},"weapons":{"Plagueburst Mortar":{"name":"Plagueburst Mortar","range":"48\"","type":"Heavy D6","s":"8","ap":"-2","d":"2","abilities":"Blast. Plague Weapon. This weapon can target units that are not visible to the bearer."},"Heavy slugger":{"name":"Heavy slugger","range":"36\"","type":"Heavy 4","s":"5","ap":"-1","d":"1","abilities":"-"},"Entropy cannon":{"name":"Entropy cannon","range":"36\"","type":"Heavy 1","s":"8","ap":"-4","d":"D3+3","abilities":"Plague Weapon"}},"rules":["Contagions of Nurgle"],"uuid":"e06f6785","unassignedWeapons":[],"pl":9,"isSingleModel":true,"woundTrack":{"Plagueburst Crawler":{"6+":["9\"","3+","7"],"3-5":["6\"","4+","6"],"1-2":["4\"","5+","5"]}}}},"uiHeight":"700","uiWidth":"1200","decorativeNames":"false","baseScript":"\n\n\n\n\nlocal scriptingFunctions\n\n\n\n\nlocal measuringCircles = {}\r\nlocal isCurrentlyCheckingCoherency = false\r\nlocal hasBuiltUI = false\r\nlocal previousHighlightColor = nil\r\nlocal MM_TO_INCH = 0.0393701\r\nlocal MEASURING_RING_Y_OFFSET = 0.17\r\nlocal VALID_BASE_SIZES_IN_MM = {\r\n    {x = 25, z = 25},\r\n    {x = 28, z = 28},\r\n    {x = 30, z = 30},\r\n    {x = 32, z = 32},\r\n    {x = 40, z = 40},\r\n    {x = 50, z = 50},\r\n    {x = 55, z = 55},\r\n    {x = 60, z = 60},\r\n    {x = 65, z = 65},\r\n    {x = 80, z = 80},\r\n    {x = 90, z = 90},\r\n    {x = 100, z = 100},\r\n    {x = 130, z = 130},\r\n    {x = 160, z = 160},\r\n    {x = 25, z = 75},\r\n    {x = 75, z = 25},\r\n    {x = 35.5, z = 60},\r\n    {x = 60, z = 35.5},\r\n    {x = 40, z = 95},\r\n    {x = 95, z = 40},\r\n    {x = 52, z = 90},\r\n    {x = 90, z = 52},\r\n    {x = 70, z = 105},\r\n    {x = 105, z = 70},\r\n    {x = 92, z = 120},\r\n    {x = 120, z = 92},\r\n    {x = 95, z = 150},\r\n    {x = 150, z = 95},\r\n    {x = 109, z = 170},\r\n    {x = 170, z = 109}\r\n}\r\nlocal WOUND_COLOR_CUTOFFS = {\r\n    {g=0}, -- 1\r\n    {g=1}, -- 2\r\n    {g=2, o=1}, -- 3\r\n    {g=2, o=1}, -- 4\r\n    {g=3, o=1}, -- 5\r\n    {g=4, o=2}, -- 6\r\n    {g=5, o=2}, -- 7\r\n    {g=6, o=3}, -- 8\r\n    {g=6, o=3}, -- 9\r\n}\r\nlocal WOUND_TRACK_COLORS = {\r\n    { \"[00ff16]\" },\r\n    { \"[00ff16]\", \"[ff0000]\" },\r\n    { \"[00ff16]\", \"[ffca00]\", \"[ff0000]\" },\r\n    { \"[00ff16]\", \"[ffca00]\", \"[ff7900]\", \"[ff0000]\" },\r\n    { \"[00ff16]\", \"[8bff00]\", \"[ffca00]\", \"[ff7900]\", \"[ff0000]\" }\r\n}\r\nlocal BRACKET_VALUE_COLORS = {\r\n    { \"[98ffa7]\" },\r\n    { \"[98ffa7]\", \"[e9a2a2]\" },\r\n    { \"[98ffa7]\", \"[ffe298]\", \"[e9a2a2]\" },\r\n    { \"[98ffa7]\", \"[ffe298]\", \"[feb17e]\", \"[e9a2a2]\" },\r\n    { \"[98ffa7]\", \"[c8ff98]\", \"[ffe298]\", \"[feb17e]\", \"[e9a2a2]\" }\r\n}\r\nlocal BRACKET_VALUE = \"${color}${val}[-]\"\r\nlocal dataCardHeight = 300 \r\n-- starting to calculate height of the dataCard: keywords and each section is \r\n-- 40px by default (will add row heights later), spacing adds 30 between each,\r\n-- and I want 10 extra pixels at the bottom for a total of 60+30+40+30+40+30+40+10 = 260 (+10 for unknown reason) (70 for keywords)\r\nlocal uiTemplates = {\r\n    abilities = [[<Row color=\"${rowParity}\" dontUseTableRowBackground=\"true\" preferredHeight=\"80\">\r\n                    <Cell><Text resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" preferredHeight=\"20\" fontStyle=\"Bold\" alignment=\"MiddleCenter\">${name}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${desc}</Text></Cell>\r\n                </Row>]],\r\n    models = [[ <Row color=\"${rowParity}\" dontUseTableRowBackground=\"true\" preferredHeight=\"60\">\r\n                    <Cell><Text resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" preferredHeight=\"20\" fontStyle=\"Bold\" alignment=\"MiddleCenter\">${name}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${m}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${ws}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${bs}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${s}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${t}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${w}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${a}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${ld}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${sv}</Text></Cell>\r\n                </Row>]],\r\n    weapons = [[ <Row color=\"${rowParity}\" dontUseTableRowBackground=\"true\" preferredHeight=\"60\">\r\n                    <Cell><Text resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" preferredHeight=\"20\" fontStyle=\"Bold\" alignment=\"MiddleCenter\">${name}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${range}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${type}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${s}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${ap}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${d}</Text></Cell>\r\n                    <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${abilities}</Text></Cell>\r\n                </Row>]],\r\n    powersKnown = [[<Row color=\"${rowParity}\" dontUseTableRowBackground=\"true\" preferredHeight=\"100\">\r\n                        <Cell><Text resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" preferredHeight=\"20\" fontStyle=\"Bold\" alignment=\"MiddleCenter\">${name}</Text></Cell>\r\n                        <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${warpCharge}</Text></Cell>\r\n                        <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${range}</Text></Cell>\r\n                        <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${details}</Text></Cell>\r\n                    </Row>]],\r\n    psykerProfiles = [[ <Row color=\"${rowParity}\" dontUseTableRowBackground=\"true\" alignment=\"MiddleCenter\" preferredHeight=\"100\">\r\n                            <Cell><Text resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" preferredHeight=\"20\" fontStyle=\"Bold\" alignment=\"MiddleCenter\">${name}</Text></Cell>\r\n                            <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${cast}</Text></Cell>\r\n                            <Cell><Text fontStyle=\"Normal\" fontSize=\"18\" alignment=\"MiddleCenter\">${deny}</Text></Cell>\r\n                            <Cell><Text fontStyle=\"Normal\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"6\" resizeTextMaxSize=\"20\" alignment=\"MiddleCenter\">${known}</Text></Cell>\r\n                        </Row>]],\r\n    agenda = [[ <HorizontalLayout childForceExpandWidth=\"false\" childForceExpandHeight=\"false\" childAlignment=\"MiddleLeft\">\r\n                    <Text fontStyle=\"Normal\" fontSize=\"24\" alignment=\"MiddleCenter\" flexibleWidth=\"1\">${counterName}</Text>\r\n                    <HorizontalLayout childForceExpandWidth=\"false\" childForceExpandHeight=\"false\" childAlignment=\"MiddleLeft\" spacing=\"5\">\r\n                        <Button transition=\"None\" preferredHeight=\"24\" preferredWidth=\"24\" padding=\"3 3 3 3\" resizeTextForBestFit=\"true\" textAlignment=\"MiddleCenter\" onClick=\"${guid}/decrementTallyCounter(${counterName})\">-</Button>\r\n                        <Text fontStyle=\"Bold\" fontSize=\"26\" color=\"#000000\" id=\"${counterID}\">${counterValue}</Text>\r\n                        <Button transition=\"None\" preferredHeight=\"24\" preferredWidth=\"24\" padding=\"3 3 3 3\" resizeTextForBestFit=\"true\" textAlignment=\"MiddleCenter\" onClick=\"${guid}/incrementTallyCounter(${counterName})\">+</Button>\r\n                    </HorizontalLayout>\r\n                </HorizontalLayout>]],\r\n    -- this is here and not in xml because we have to provide the guid, otherwise it will try and run on Global\r\n    buttons = [[<Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#BB2222\" onClick=\"${guid}/highlightUnit(Red)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#22BB22\" onClick=\"${guid}/highlightUnit(Green)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#2222BB\" onClick=\"${guid}/highlightUnit(Blue)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#BB22BB\" onClick=\"${guid}/highlightUnit(Purple)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#DDDD22\" onClick=\"${guid}/highlightUnit(Yellow)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#FFFFFF\" onClick=\"${guid}/highlightUnit(White)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#DD6633\" onClick=\"${guid}/highlightUnit(Orange)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#29D9D9\" onClick=\"${guid}/highlightUnit(Teal)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#DD77CC\" onClick=\"${guid}/highlightUnit(Pink)\"></Button>\r\n    <Button padding=\"3 3 3 3\" preferredHeight=\"20\" preferredWidth=\"${width}\" color=\"#BBBBBB\" onClick=\"${guid}/unhighlightUnit\"></Button>]]\r\n}\n\n\n\n\nlocal AGENDA_MANAGER_TAG_PATTERN = \"am:(.+)\"\r\nlocal crusadeCardData = {\r\n    toggles = {\r\n        ccBlooded = false,\r\n        ccBattleHardened = false,\r\n        ccHeroic = false,\r\n        ccLegendary = false\r\n    },\r\n    fields = {\r\n        ccUnitName = \"\",\r\n        ccBattlefieldRole = \"\",\r\n        ccCrusadeFaction = \"\",\r\n        ccSelectableKeywords = \"\",\r\n        ccUnitType = \"\",\r\n        ccEquipment = \"\",\r\n        ccPsychicPowers = \"\",\r\n        ccWarlordTrait = \"\",\r\n        ccRelic = \"\",\r\n        ccOtherUpgrades = \"\",\r\n        ccBattleHonors = \"\",\r\n        ccBattleScars = \"\"\r\n    },\r\n    counters= {\r\n        pl = 0, \r\n        xp = 0, \r\n        cl = 0, \r\n        totalKills = 0, \r\n        played = 0, \r\n        survived = 0\r\n    }\r\n}\n\n\n\n\n--[[ SCRIPTING FUNCTION DEFINITIONS ]]--\r\n\r\n\r\nfunction none() end\r\n\r\n\r\nfunction changeModelWoundCount(mod, target)\r\n    local name = target.getName()\r\n    local _,_, current, total = name:find(\"([0-9]+)/([0-9]+)\")\r\n    local colors,newName,currentBracket,updatedName,currentColor\r\n\r\n    if current == nil then return end\r\n\r\n    current = math.max(tonumber(current) + mod, 0)\r\n    total = tonumber(total)\r\n    newName = string.gsub(name, \"([0-9]+)/([0-9]+)\", current..\"/\"..total, 1)\r\n\r\n    if current == 0 then\r\n        currentColor = \"[ff0000]\"\r\n    else\r\n        local bracketData,bracketName,bracketProfileName\r\n        \r\n        if unitData.woundTrack ~= nil then\r\n            if len(unitData.woundTrack) == 1 then\r\n                for key,bracket in pairs(unitData.woundTrack) do\r\n                    bracketData = bracket\r\n                    bracketName = key\r\n                end\r\n            else\r\n                -- not using hasTag because we don't know what tag to look for, only prefix\r\n                for _,tag in pairs(target.getTags()) do\r\n                    if tag:find(\"^wt:\") ~= nil then\r\n                        _,_,bracketName = tag:find(\"^wt:(.+)\")\r\n                        bracketData = unitData.woundTrack[bracketName]\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        if bracketData == nil then\r\n            colors = WOUND_COLOR_CUTOFFS[total]\r\n            currentColor =  current > colors.g and \"[00ff16]\" \r\n                            or (colors.o ~= nil and current > colors.o) and \"[ffca00]\" or \"[ff0000]\"\r\n        else\r\n            currentBracket = 1\r\n\r\n            for key,_ in pairs(bracketData) do\r\n                local cutoff,_ = key:gsub(\"(%d+)%-%d+%+?\", \"%1\")\r\n                if current >= tonumber(cutoff) then \r\n                    bracketProfileName = bracketName..\" (\"..key..\")\"\r\n                    break \r\n                end\r\n\r\n                currentBracket = currentBracket + 1\r\n            end\r\n\r\n            updateBracketCharacteristics(currentBracket, bracketData, bracketName, bracketProfileName, target)\r\n            currentColor = WOUND_TRACK_COLORS[len(bracketData)][currentBracket]\r\n        end\r\n    end\r\n\r\n    updatedName = string.gsub(newName, \"^%[%w+]\", currentColor, 1)\r\n    \r\n    target.setName(updatedName)\r\nend\r\n\r\nfunction updateBracketCharacteristics(bracket, bracketData, bracketName, bracketProfileName, target)\r\n    local desc = target.getDescription()\r\n    local updatedBracketCharacteristics,updatedHeadings = \"\",\"[56f442]\"\r\n    local bracketProfile,changingCharacteristics\r\n\r\n    for _,profile in pairs(unitData.models) do\r\n        if profile.name == bracketProfileName then bracketProfile = profile end\r\n    end\r\n    \r\n    for heading,value in pairs(bracketProfile) do \r\n        if heading ~= \"name\" and heading ~= \"rowParity\" then \r\n            updatedBracketCharacteristics = updatedBracketCharacteristics..(isInList(heading, unitData.changingCharacteristics[bracketName]) \r\n                                and interpolate(BRACKET_VALUE, { \r\n                                    color = BRACKET_VALUE_COLORS[len(bracketData)][bracket],\r\n                                    val = value \r\n                                }) \r\n                                or value)..\"   \"\r\n\r\n            updatedHeadings = updatedHeadings..formatHeading(heading, value)\r\n        end\r\n    end\r\n\r\n    updatedBracketCharacteristics = updatedHeadings..\"[-]\\n\"..updatedBracketCharacteristics..\"[-][-]\"\r\n\r\n    target.setDescription(desc:gsub(\"%[56f442].-%[%-%]%[%-%]\",updatedBracketCharacteristics))\r\nend\r\n\r\n-- formats the heading line for the characteristics section in a model's description\r\n-- the spacing is based on the values given so that they line up properly\r\nfunction formatHeading(heading, value)\r\n    local spacing = value:gsub(\"\\\\\",\"\"):len()-heading:len()\r\n    \r\n    if heading == \"ws\" or heading == \"m\" or heading ==\"a\" then \r\n        spacing = spacing + 2\r\n    else\r\n        spacing = spacing + 3\r\n    end\r\n\r\n    if (heading == \"m\" and value:len() > 2) or ((heading == \"a\" or heading == \"s\" or heading == \"t\" or heading == \"w\") and value:len() > 1) then\r\n        if heading == \"m\" and value ~= \"-\" and value:find('%-') ~= nil then\r\n            heading = heading..\"   \"\r\n        end\r\n\r\n        heading = \" \"..heading\r\n    end\r\n\r\n    return capitalize(heading)..string.rep(\" \", spacing)\r\nend\r\n\r\n-- decides whether to fully capitalize or (in the case of ld and sv) titlecase a string\r\nfunction capitalize(heading)\r\n    if heading == \"ld\" or heading == \"sv\" then return titlecase(heading) end\r\n    return heading:upper()\r\nend\r\n\r\n-- only use this for changing ld and sv to Ld and Sv\r\nfunction titlecase(s)\r\n    return s:gsub(\"^(%w)\", function (a) return a:upper() end)\r\nend\r\n\r\n\r\nfunction showCrusadeCard(playerColor)\r\n    loadCrusadeCard()\r\n    -- delay to wait for update\r\n    Wait.frames(function () showCard(\"crusadeCard\", playerColor) end, 2)\r\nend\r\n\r\n\r\nfunction toggleRectangularMeasuring(playerColor, target)\r\n    local isRectangular = target.hasTag(\"rectangularMeasuring\")\r\n\r\n    if not isRectangular then \r\n        target.addTag(\"rectangularMeasuring\")\r\n        broadcastToAll(\"Model set to rectangular measuring\")\r\n    else \r\n        target.removeTag(\"rectangularMeasuring\") \r\n        broadcastToAll(\"Model set to round measuring\")\r\n    end\r\n\r\n    changeMeasurementCircle(0, target)\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ EVENT HANDLERS ]]--\r\n\r\n\r\nfunction onLoad(savedState)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n\r\n    local hasLoaded = self.getVar(\"hasLoaded\")\r\n    if hasLoaded == nil or not hasLoaded then\r\n        local decodedState = savedState == nil and nil or JSON.decode(savedState)\r\n        \r\n        if decodedState ~= nil and loadDecodedState ~= nil then\r\n            loadDecodedState(decodedState)\r\n        elseif loadDefaultValues ~= nil then\r\n            loadDefaultValues()\r\n        end\r\n\r\n        setContextMenuItemsForUnit()\r\n        \r\n        --Wait.frames(function () buildUI() end, 2)\r\n\r\n        for _,model in ipairs(getObjectsWithTag(\"uuid:\"..unitData.uuid)) do\r\n            model.setVar(\"hasLoaded\", true)\r\n        end\r\n    end\r\nend\r\n\r\n\r\nfunction onSave()\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n    if getCrusadeCardSaveData ~= nil then\r\n        return JSON.encode(getCrusadeCardSaveData())\r\n    end\r\nend\r\n\r\n\r\nfunction onScriptingButtonDown(index, playerColor)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n\r\n    local player = Player[playerColor]\r\n    local hoveredObject = player.getHoverObject()\r\n    \r\n    -- if the hovered object has a matching unitID, then it is part of this model's unit and thus is a valid target\r\n    local isHoveringValidTarget = hoveredObject ~= nil and hoveredObject.hasTag(\"uuid:\"..unitData.uuid)\r\n    \r\n    if isHoveringValidTarget then scriptingFunctions[index](playerColor, hoveredObject, player) end\r\nend\r\n\r\n\r\nfunction onObjectDrop(playerColor, droppedObject)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n    if isCurrentlyCheckingCoherency and\r\n        droppedObject ~= nil and \r\n        unitData ~= nil and\r\n        droppedObject.hasTag(\"uuid:\"..unitData.uuid) then\r\n            droppedObject.setLock(true)\r\n            -- wait a frame for locking to cancel momentum\r\n            Wait.frames(function ()\r\n                droppedObject.setLock(false)\r\n                highlightCoherency()\r\n            end, 1)\r\n    end\r\nend\r\n\r\n\r\nfunction onObjectRotate(object, spin, flip, playerColor, oldSpin, oldFlip)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n    if isCurrentlyCheckingCoherency and\r\n        flip ~= oldFlip and  -- update on model flip\r\n        object.hasTag(\"uuid:\"..unitData.uuid) then\r\n        -- wait for a bit, otherwise the model will still be considered face down when its flipped face up and vice versa\r\n        Wait.time(|| highlightCoherency(), 0.3) \r\n    end\r\nend\r\n\r\n\r\nfunction onPlayerAction(player, action, targets)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n    if action == Player.Action.Paste then\r\n        local unitTag = \"uuid:\"..unitData.uuid\r\n        for _,object in ipairs(targets) do\r\n            if object.hasTag(unitTag) and object.hasTag(\"leaderModel\") then\r\n                object.setLuaScript(\"\")\r\n                object.removeTag(\"leaderModel\")\r\n            end\r\n        end\r\n    elseif action == Player.Action.Delete then\r\n        local unitTag = \"uuid:\"..unitData.uuid\r\n        for _,object in ipairs(targets) do\r\n            if object == self then \r\n                local modelsInUnit = getObjectsWithTag(unitTag)\r\n                local modelsInUnitNotBeingDeleted = filter(modelsInUnit, |model| not includes(targets, model))\r\n                if #modelsInUnitNotBeingDeleted > 1 then\r\n                    local newLeader = modelsInUnitNotBeingDeleted[1]\r\n\r\n                    updateEventHandlers(newLeader.getGUID())\r\n\r\n                    Wait.frames(function ()\r\n                        newLeader.setLuaScript(self.getLuaScript())\r\n                        newLeader.UI.setXml(self.UI.getXml())\r\n                        newLeader.addTag(\"leaderModel\")\r\n                    end, 2)\r\n                    \r\n                    if loadCrusadeCard ~= nil then\r\n                        Wait.frames(|| newLeader.call(\"loadCrusadeCard\", crusadeCardData), 2)\r\n                    end\r\n\r\n                    self.removeTag(\"leaderModel\")\r\n                    --[[ local found = true\r\n\r\n                    for _,model in ipairs(modelsInUnit) do\r\n                        if model ~= self and not isInList(model, targets) then\r\n                            found = false\r\n                            break\r\n                        end\r\n                    end\r\n                    -- if there are going to be any models left in the unit that arent this one,\r\n                    -- prevent deletion\r\n                    if not found then\r\n                        broadcastToColor(\"Please don't delete me, I'm needed for scripting!\", player.color, \"Red\")\r\n                        return false\r\n                    end --]]\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction onObjectSpawn(object)\r\n    if not self.hasTag(\"leaderModel\") then return end -- prevents firing on objects we don't want firing\r\n    \r\n    if object ~= self and object.hasTag(\"leaderModel\") and object.hasTag(\"uuid:\"..unitData.uuid) then\r\n        object.removeTag(\"leaderModel\")\r\n        object.setLuaScript(\"\")\r\n        --[[ local unitModels = getObjectsWithTag(\"uuid:\"..unitData.uuid)\r\n\r\n        for _,model in ipairs(unitModels) do\r\n            if model ~= object and model.hasTag(\"leaderModel\") then\r\n                object.removeTag(\"leaderModel\")\r\n                object.setLuaScript(\"\")\r\n                break\r\n            end\r\n        end --]]\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ UI UTILITY FUNCTIONS ]]--\r\n\r\n\r\nfunction showCard(cardName, playerColor, doBeforeShowing, doAfterShowing)\r\n    local timeToWait = 0\r\n    \r\n    if not hasBuiltUI then \r\n        buildUI()\r\n        hasBuiltUI = true\r\n        timeToWait = 2\r\n    end\r\n\r\n    -- wait in case ui needs to update\r\n    Wait.frames(function ()\r\n        local globalUI = Global.UI.getXmlTable()\r\n        local selfUI = self.UI.getXmlTable()\r\n        local formattedCardName = \"ymc-\"..cardName..\"-\"..unitData.uuid..\"-\"..playerColor\r\n        local shownYet = false\r\n\r\n        -- yes, I know we go through the table twice, I don't like it\r\n        for _,element in ipairs(globalUI) do\r\n            recursivelyCleanElement(element)\r\n\r\n            if element.attributes.id == formattedCardName then\r\n                shownYet = true\r\n\r\n                if element.attributes.visibility ~= playerColor or not element.attributes.active then\r\n                    element.attributes.visibility = playerColor\r\n                    element.attributes.active = true\r\n                end\r\n            end\r\n        end\r\n    \r\n        if not shownYet then\r\n            local cardToShow = filter(selfUI[1].children, |child| child.attributes.id == cardName)[1]\r\n            cardToShow.attributes.id = formattedCardName\r\n            cardToShow.attributes.visibility = playerColor\r\n            cardToShow.attributes.active = true\r\n        \r\n            recursivelyCleanElement(cardToShow)\r\n            table.insert(globalUI, cardToShow)\r\n    \r\n            UI.setXmlTable(globalUI)\r\n        end\r\n    end, timeToWait)\r\nend\r\n\r\n\r\nfunction hideCard(player, card)\r\n    local playerColor = player.color    \r\n\r\n    if (player.color:find(\"^%w+$\")) == nil then playerColor = \"Grey\" end\r\n\r\n    local formattedCardName = \"ymc-\"..card..\"-\"..unitData.uuid..\"-\"..playerColor\r\n\r\n    UI.setAttribute(formattedCardName, \"visibility\", \"None\")\r\n    \r\n    UI.setAttribute(formattedCardName, \"active\", false)\r\n    --UI.hide(formattedCardName)\r\n\r\n    Wait.time(function()\r\n        local currentUI = UI.getXmlTable()\r\n        local foundVisibleCard = false\r\n\r\n        for _,element in ipairs(currentUI) do\r\n            if element.attributes ~= nil and\r\n                element.attributes.id ~= nil and\r\n                (element.attributes.id:find(\"^ymc-\")) ~= nil and -- if we find a card\r\n                element.attributes.visibility ~= nil and\r\n                element.attributes.visibility ~= \"\" and\r\n                element.attributes.visibility ~= \"None\" then\r\n                    foundVisibleCard = true\r\n                    break\r\n            end\r\n\r\n            recursivelyCleanElement(element)\r\n        end\r\n\r\n        if foundVisibleCard then return end\r\n\r\n        currentUI = filter(currentUI, |element| element.attributes.id == nil or (element.attributes.id:find(\"^ymc-\")) == nil)\r\n\r\n        UI.setXmlTable(currentUI)\r\n        --UI.setAttribute(\"container\", \"visibility\", \"hidden\")\r\n    end, 0.11)\r\nend\r\n\r\n-- builds the XML string for the given section based on data defined in unitData (see top of file)\r\n-- note: this is just for dataCard, although theoretically it can be used for any section\r\nfunction buildXMLForSection(section)\r\n    local uiString = \"\"     -- old: uiTemplates[section..\"Header\"]\r\n    local _,_,rowHeight = uiTemplates[section].find(uiTemplates[section], 'Row.-preferredHeight=\"(%d+)\"') -- get the height of the row to be added\r\n    local rowParity = \"White\"\r\n    for _,entry in pairs(unitData[section]) do\r\n        entry[\"rowParity\"] = rowParity\r\n        uiString = uiString..interpolate(uiTemplates[section], entry)\r\n        dataCardHeight = dataCardHeight + tonumber(rowHeight)\r\n        rowParity = rowParity == \"White\" and \"#f9f9f9\" or \"White\"\r\n    end\r\n    self.UI.setValue(section, uiString)\r\nend\r\n\r\n\r\nfunction buildUI()\r\n    self.UI.setAttribute(\"ym-container\", \"unit-id\", unitData.uuid)\r\n\r\n    self.UI.setAttribute(\"dataCard\", \"height\", unitData.uiHeight)\r\n    self.UI.setAttribute(\"dataCard\", \"width\", unitData.uiWidth)\r\n\r\n    self.UI.setValue(\"data-unitName\", unitData.unitName)\r\n    self.UI.setValue(\"factionKeywords\", unitData.factionKeywords)\r\n    self.UI.setValue(\"keywords\", unitData.keywords)\r\n\r\n    if unitData.keywords:len() < 85 then\r\n        self.UI.setAttribute(\"keywordContainer\", \"preferredHeight\", 40)  \r\n        self.UI.setAttribute(\"keywordList\", \"preferredHeight\", 20)   \r\n        \r\n        dataCardHeight = dataCardHeight - 30 -- subtract extra height for keyword box\r\n    end\r\n\r\n    buildXMLForSection(\"abilities\")\r\n    buildXMLForSection(\"models\")\r\n    buildXMLForSection(\"weapons\")\r\n\r\n    if unitData.psykerProfiles ~= nil then\r\n        buildXMLForSection(\"powersKnown\")\r\n        buildXMLForSection(\"psykerProfiles\")\r\n        \r\n        self.UI.setAttribute(\"powersKnownContainer\", \"active\", true)   \r\n        self.UI.setAttribute(\"psykerProfilesContainer\", \"active\", true)  \r\n\r\n        dataCardHeight = dataCardHeight + 140 -- add space for two headers (40px each) and two spaces (30px each)\r\n    end\r\n\r\n    local guid = self.getGUID()\r\n\r\n    self.UI.setAttribute(\"dataCardCloseButton\", \"onClick\", guid..\"/hideCard(dataCard)\")\r\n    self.UI.setValue(\"highlightButtonsContainer\", interpolate(uiTemplates.buttons, { guid=guid, width=(unitData.uiWidth/10)-4 }))\r\n    \r\n    self.UI.setAttribute(\"dataCardContentContainer\", \"height\", dataCardHeight)\r\n\r\n    if buildCrusadeUI ~= nil then buildCrusadeUI(guid) end\r\nend\r\n\r\nfunction setContextMenuItemsForUnit()\r\n    local hasLoaded = self.getVar(\"hasLoaded\")\r\n    if hasLoaded == nil or not hasLoaded then\r\n        local unit = getObjectsWithTag(\"uuid:\"..unitData.uuid)\r\n    \r\n        if not unitData.isSingleModel and #unit > 1 then\r\n            for _,model in ipairs(unit) do\r\n                model.addContextMenuItem(\"Toggle Coherency ✓\", toggleCoherencyChecking)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction updateEventHandlers(guid)\r\n    self.UI.setAttribute(\"dataCardCloseButton\", \"onClick\", guid..\"/hideCard(dataCard)\")\r\n    self.UI.setValue(\"highlightButtonsContainer\", interpolate(uiTemplates.buttons, { guid=guid, width=(unitData.uiWidth/10)-4 }))\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ HIGHLIGHTING FUNCTIONS ]]--\r\n\r\n\r\nfunction highlightUnit(player, color)\r\n    for _,model in pairs(getObjectsWithTag(\"uuid:\"..unitData.uuid)) do\r\n        model.highlightOn(color)\r\n        model.setVar(\"currentHighlightColor\", color)\r\n    end\r\nend\r\n\r\nfunction unhighlightUnit()\r\n    for _,model in pairs(getObjectsWithTag(\"uuid:\"..unitData.uuid)) do\r\n        model.highlightOff()\r\n        model.setVar(\"currentHighlightColor\", nil)\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ UNIT COHERENCY FUNCTIONS ]]--\r\n\r\nfunction toggleCoherencyChecking(playerColor)\r\n    isCurrentlyCheckingCoherency = not isCurrentlyCheckingCoherency\r\n\r\n    if isCurrentlyCheckingCoherency then\r\n        highlightCoherency()\r\n        broadcastToColor(\"Checking coherency for \"..unitData.unitDecorativeName, playerColor, playerColor)\r\n    else\r\n        local oldHighlight = self.getVar(\"currentHighlightColor\")\r\n\r\n        if oldHighlight == nil then\r\n            unhighlightUnit()\r\n        else\r\n            highlightUnit(nil, oldHighlight)\r\n        end\r\n\r\n        broadcastToColor(\"No longer checking coherency for \"..unitData.unitDecorativeName, playerColor, playerColor)\r\n    end\r\nend\r\n\r\nfunction highlightCoherency()\r\n    local modelsInUnit = getObjectsWithTag(\"uuid:\"..unitData.uuid)\r\n    local filteredUnits = {}\r\n\r\n    for _,model in ipairs(modelsInUnit) do\r\n        if model.is_face_down then -- ignore face-down models\r\n            model.highlightOff()\r\n        else\r\n            table.insert(filteredUnits, model)\r\n        end\r\n    end\r\n\r\n    local coherencyCheckNum = (#filteredUnits > 5) and 2 or 1\r\n    local coherencyGroups = getCoherencyGroups(filteredUnits, coherencyCheckNum)\r\n    local numberOfBlobs = len(coherencyGroups)\r\n    \r\n    if numberOfBlobs == 0 then return\r\n    elseif numberOfBlobs > 1 then\r\n        for _,blob in ipairs(coherencyGroups) do\r\n            for modelIdx,_ in pairs(blob) do\r\n                filteredUnits[modelIdx].highlightOff()\r\n                filteredUnits[modelIdx].highlightOn(\"Yellow\")\r\n            end\r\n        end\r\n    else\r\n        -- don't just highlight all the models in the unit, there might be other models\r\n        -- that were purely outside of coherency (and thus not in a blob)\r\n        for modelIdx,_ in pairs(coherencyGroups[1]) do\r\n            filteredUnits[modelIdx].highlightOff()\r\n            filteredUnits[modelIdx].highlightOn(\"Green\")\r\n        end\r\n    end\r\nend\r\n\r\nfunction getCoherencyGroups(modelsToSearch, numberToLookFor)\r\n    local edges = getCoherencyGraph(modelsToSearch)\r\n    local blobs = {}\r\n    local modelsToIgnore = {}\r\n    \r\n    for idx,model in ipairs(modelsToSearch) do\r\n        if edges[idx] == nil or #edges[idx] < numberToLookFor then -- the model is out of coherency\r\n            model.highlightOff()\r\n            model.highlightOn(\"Red\")\r\n\r\n            modelsToIgnore[idx] = true\r\n            -- remove from any blobs the model is already in\r\n            for _,blob in ipairs(blobs) do\r\n                blob[idx] = nil\r\n            end\r\n        else\r\n            local found = false\r\n            -- see if this index exists in a blob, if it does, ignore it\r\n            for _,blob in ipairs(blobs) do\r\n                if blob[idx] == true then\r\n                    found = true\r\n                    break\r\n                end\r\n            end\r\n            \r\n            if not found then\r\n                local newBlob = {}\r\n\r\n                table.insert(blobs, newBlob)\r\n                addModelsToBlobRecursive(idx, newBlob, edges, modelsToIgnore)\r\n            end\r\n        end\r\n    end\r\n\r\n    return blobs\r\nend\r\n\r\nfunction getCoherencyGraph(modelsToSearch)\r\n    local edges = {}\r\n\r\n    for idx=1,#modelsToSearch do\r\n        for otherIdx=idx+1,#modelsToSearch do\r\n            local firstPosition = modelsToSearch[idx].getPosition()\r\n            local firstSize = determineBaseInInches(modelsToSearch[idx])\r\n            local secondPosition = modelsToSearch[otherIdx].getPosition()\r\n            local secondSize = determineBaseInInches(modelsToSearch[otherIdx])\r\n            local verticalDisplacement = distanceBetweenVertical(firstPosition, secondPosition)\r\n\r\n            -- handle circular bases\r\n            if firstSize.x == firstSize.z and secondSize.x == secondSize.z then\r\n                if distanceBetween2D(firstPosition, firstSize.x, secondPosition, secondSize.x) <= 2 and\r\n                    verticalDisplacement <= 5 then \r\n                    -- store all edges of a graph where models are nodes and edges represent coherency\r\n                    storeEdges(edges, idx, otherIdx)\r\n                end\r\n            else -- handle non-circular bases\r\n                if firstSize.x ~= firstSize.z and secondSize.x ~= secondSize.z then -- handle two ovals\r\n                    -- if the bases were circles with radiuses = minor axes and they are in coherency,\r\n                    -- the ovals must be in coherency\r\n                    if distanceBetween2D(firstPosition, math.min(firstSize.x, firstSize.z), secondPosition, math.min(secondSize.x, secondSize.z)) <= 2 and\r\n                        verticalDisplacement <= 5 then  \r\n                        -- store edges in graph\r\n                        storeEdges(edges, idx, otherIdx)\r\n                        \r\n                    -- if the bases were circles with radiuses = major axes and they are out of coherency,\r\n                    -- there is no way for the ovals to be in coherency\r\n                    elseif not (distanceBetween2D(firstPosition, math.max(firstSize.x, firstSize.z), secondPosition, math.max(secondSize.x, secondSize.z)) > 2 or\r\n                                verticalDisplacement > 5) then\r\n                        -- only way to get here is if coherency is uncertain, so now check a little more precisely (only a little)\r\n                        if distanceBetween2D(firstPosition, (firstSize.x+firstSize.z)/2, secondPosition, (secondSize.x+secondSize.z)/2) <= 2 and\r\n                            verticalDisplacement <= 5 then\r\n                            storeEdges(edges, idx, otherIdx)\r\n                        end\r\n                    end\r\n                else -- handle one circle and one oval\r\n                    local oval,ovalPosition,circle,circlePosition\r\n\r\n                    if firstSize.x ~= firstSize.z then\r\n                        oval = firstSize\r\n                        ovalPosition = firstPosition\r\n                        circle = secondSize\r\n                        circlePosition = secondPosition\r\n                    else\r\n                        oval = secondSize\r\n                        ovalPosition = secondPosition\r\n                        circle = firstSize\r\n                        circlePosition = firstPosition\r\n                    end\r\n\r\n                    -- if the oval base was a circle with radius = minor axis and they are in coherency,\r\n                    -- the models must be in coherency\r\n                    if distanceBetween2D(circlePosition, circle.x, ovalPosition, math.min(oval.x, oval.z)) <= 2 and\r\n                        verticalDisplacement <= 5 then  \r\n                        storeEdges(edges, idx, otherIdx)\r\n                        \r\n                    -- if the oval base was a circle with radius = major axis and they are out of coherency,\r\n                    -- there is no way for the models to be in coherency\r\n                    elseif not (distanceBetween2D(circlePosition, circle.x, ovalPosition, math.max(oval.x, oval.z)) > 2 or\r\n                                verticalDisplacement > 5) then\r\n                        -- only way to get here is if coherency is uncertain, so now check a little more precisely (only a little)\r\n                        if distanceBetween2D(circlePosition, circle.x, ovalPosition, (oval.x+oval.z)/2) <= 2 and\r\n                            verticalDisplacement <= 5 then\r\n                            storeEdges(edges, idx, otherIdx)\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    return edges\r\nend\r\n\r\nfunction storeEdges(edges, idx, otherIdx)\r\n    if edges[idx] == nil then edges[idx] = { otherIdx }\r\n    else table.insert(edges[idx], otherIdx) end\r\n\r\n    if edges[otherIdx] == nil then edges[otherIdx] = { idx }\r\n    else table.insert(edges[otherIdx], idx) end\r\nend\r\n\r\nfunction addModelsToBlobRecursive(idx, blob, edges, modelsToIgnore)\r\n    -- at this point, idx should not exist in any blobs\r\n    if modelsToIgnore[idx] ~= nil then return end\r\n    if blob[idx] ~= nil then return end\r\n\r\n    blob[idx] = true\r\n\r\n    for _,edge in ipairs(edges[idx]) do\r\n        addModelsToBlobRecursive(edge, blob, edges, modelsToIgnore)\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ UTILITY FUNCTIONS ]]--\r\n\r\n\r\nfunction interpolate(templateString, replacementValues)\r\n    return (templateString:gsub('($%b{})', function(w) return replacementValues[w:sub(3, -2)] or w end))\r\nend\r\n\r\n\r\nfunction isInList(key, list) \r\n    for _,k in pairs(list) do\r\n        if k == key then return true end\r\n    end\r\n    return false\r\nend\r\n\r\nfunction len(t)\r\n    local count = 0\r\n\r\n    for _,_ in pairs(t) do\r\n        count = count + 1\r\n    end\r\n\r\n    return count\r\nend\r\n\r\nfunction distanceBetween2D(firstModelPosition, firstModelRadius, secondModelPosition, secondModelRadius)\r\n    -- generally should only be checking coherency with circular bases?\r\n    return getRawDistance(firstModelPosition.x, firstModelPosition.z, \r\n                secondModelPosition.x, secondModelPosition.z) - firstModelRadius - secondModelRadius\r\nend\r\n\r\nfunction distanceBetweenVertical(firstModelPosition, secondModelPosition)\r\n    -- vertical measuring assumes the model has a base because generally vehicles (or models without bases)\r\n    -- dont need to check coherency, and the ones that do probably wont be out of vertical coherency \r\n    -- because they cant end up on upper floors of buildings or walls\r\n    return math.abs(firstModelPosition.y - secondModelPosition.y) - 0.2 -- this is assuming the model has a base\r\nend\r\n\r\nfunction getRawDistance(firstA, firstB, secondA, secondB)\r\n    return math.sqrt( \r\n        math.pow(firstA - secondA, 2) +\r\n        math.pow(firstB - secondB, 2)\r\n    )\r\nend\r\n\r\nfunction includes(tab, val)\r\n    return find(tab, val) > 0\r\nend\r\n\r\nfunction find(tab, val)\r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return index\r\n        end\r\n    end\r\n\r\n    return -1\r\nend\r\n\r\nfunction filter(t, filterFunc)\r\n    local out = {}\r\n  \r\n    for k, v in pairs(t) do\r\n      if filterFunc(v, k, t) then table.insert(out,v) end\r\n    end\r\n  \r\n    return out\r\nend\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction map(t, mapFunc)\r\n    local out = {}\r\n\r\n    for k,v in pairs(clone(t)) do\r\n        table.insert(out, mapFunc(v,k))\r\n    end\r\n\r\n    return out\r\nend\r\n\r\nfunction recursivelyCleanElement(element)\r\n    if element.value ~= nil then\r\n        element.value = element.value:gsub(\"[ ]+\",\" \") -- remove extraneous spaces\r\n    end\r\n\r\n    if element.children ~= nil and #element.children > 0 then\r\n        for _,child in ipairs(element.children) do\r\n            recursivelyCleanElement(child)\r\n        end\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ MEASURING CIRCLE FUNCTIONS ]]--\r\n\r\n\r\nfunction assignBase(inc, target)\r\n    local savedBase = target.getTable(\"chosenBase\")\r\n\r\n    if savedBase == nil then \r\n        changeMeasurementCircle(0, target, determineBaseInInches(target))\r\n    else\r\n        local newIdx = savedBase.baseIdx + inc\r\n\r\n        if newIdx < 1 then newIdx = #VALID_BASE_SIZES_IN_MM end\r\n        if newIdx > #VALID_BASE_SIZES_IN_MM then newIdx = 1 end\r\n\r\n        local newBase = {\r\n            baseIdx = newIdx,\r\n            base = {\r\n                x = (VALID_BASE_SIZES_IN_MM[newIdx].x * MM_TO_INCH)/2,\r\n                z = (VALID_BASE_SIZES_IN_MM[newIdx].z * MM_TO_INCH)/2\r\n            }\r\n        }\r\n\r\n        target.setTable(\"chosenBase\", newBase)\r\n\r\n        changeMeasurementCircle(0, target, newBase.base)\r\n    end\r\nend\r\n  \r\n\r\nfunction determineBaseInInches(model)\r\n    local savedBase = model.getTable(\"chosenBase\")\r\n\r\n    if savedBase ~= nil then \r\n        return savedBase.base\r\n    else\r\n        local chosenBase =  VALID_BASE_SIZES_IN_MM[1]\r\n        local modelSize = model.getBoundsNormalized().size\r\n        local modelSizeX = modelSize.x\r\n        local modelSizeZ = modelSize.z\r\n        local closestSum = 10000000000\r\n        local chosenBaseIdx = 1\r\n\r\n        for k, base in pairs(VALID_BASE_SIZES_IN_MM) do\r\n            local baseInchX = (MM_TO_INCH - 0.001) * base.x\r\n            local baseInchZ = (MM_TO_INCH - 0.001) * base.z\r\n            if modelSizeX > baseInchX and modelSizeZ > baseInchZ then\r\n                local distSum = (modelSizeX - baseInchX) + (modelSizeZ - baseInchZ)\r\n                if distSum < closestSum then\r\n                    closestSum = distSum\r\n                    chosenBase = base\r\n                    chosenBaseIdx = k\r\n                end\r\n            end\r\n        end\r\n        \r\n        if chosenBase == nil then\r\n            chosenBase = { x=modelSizeX/2, z=modelSizeZ/2}\r\n        else\r\n            chosenBase = { \r\n                x = (chosenBase.x * MM_TO_INCH)/2, \r\n                z = (chosenBase.z * MM_TO_INCH)/2\r\n            }\r\n        end\r\n\r\n        model.setTable(\"chosenBase\", { baseIdx=chosenBaseIdx, base=chosenBase })\r\n\r\n        return chosenBase\r\n    end\r\nend\r\n\r\n\r\nfunction changeMeasurementCircle(change, target, presetBase)\r\n    local measuringRings = target.getTable(\"ym-measuring-circles\")\r\n    local currentColor = target.getVar(\"currentHighlightColor\")\r\n    local currentColorRadius\r\n    \r\n    if measuringRings == nil then \r\n        measuringRings = {}\r\n        currentColorRadius = 0\r\n    else\r\n        for idx=#measuringRings,1,-1 do\r\n            if (measuringRings[idx].name == currentColor) or (measuringRings[idx].name == nil and currentColor == nil) then\r\n                currentColorRadius = measuringRings[idx].radius\r\n                table.remove(measuringRings, idx)\r\n            elseif measuringRings[idx].name == \"base\" then\r\n                table.remove(measuringRings, idx)\r\n            end\r\n        end\r\n\r\n        if currentColorRadius == nil then currentColorRadius = 0 end\r\n    end\r\n    \r\n    local newRadius = math.max(currentColorRadius + change, 0)\r\n\r\n    if newRadius == 0 then\r\n        \r\n    else\r\n\r\n        local isRectangular = target.hasTag(\"rectangularMeasuring\")\r\n        local measuring = {\r\n            name = currentColor,\r\n            color = currentColor == nil and {1,0,1} or Color.fromString(currentColor),\r\n            radius = newRadius,\r\n            thickness = 0.1 * 1/(target.getScale().x),\r\n            rotation  = {270,0,0}--isRectangular and {0,0,0} or {270,0,0}\r\n        }\r\n        local base = {\r\n            name=\"base\",\r\n            color = currentColor == nil and {1,0,1} or Color.fromString(currentColor),\r\n            thickness = 0.1 * 1/(target.getScale().x),\r\n            rotation  = {270,0,0}--isRectangular and {0,0,0} or {270,0,0}\r\n        }\r\n        local measuringPoints,basePoints\r\n    \r\n        if isRectangular then\r\n            local modelBounds = target.getBoundsNormalized()\r\n    \r\n            if newRadius > 0 then\r\n                measuringPoints = getRectangleVectorPoints(newRadius, modelBounds.size.x/2, modelBounds.size.z/2, target)\r\n                basePoints = getRectangleVectorPoints(0, modelBounds.size.x/2, modelBounds.size.z/2, target)\r\n            end\r\n        else\r\n            local baseRadiuses = (presetBase == nil) and determineBaseInInches(target) or presetBase\r\n    \r\n            if newRadius > 0 then\r\n                measuringPoints = getCircleVectorPoints(newRadius, baseRadiuses.x, baseRadiuses.z, target)\r\n                basePoints = getCircleVectorPoints(0, baseRadiuses.x, baseRadiuses.z, target)\r\n            end\r\n        end\r\n        \r\n        measuring.points = measuringPoints\r\n        base.points = basePoints\r\n    \r\n        table.insert(measuringRings, measuring)\r\n        table.insert(measuringRings, base)\r\n\r\n        broadcastToAll(\"Measuring \"..tostring(newRadius)..\"\\\"\")\r\n    end\r\n    \r\n    target.setVectorLines(measuringRings)\r\n\r\n    target.setTable(\"ym-measuring-circles\", measuringRings)\r\nend\r\n\r\n\r\nfunction getCircleVectorPoints(radius, baseX, baseZ, obj)\r\n    local result = {}\r\n    local scaleFactor = 1/obj.getScale().x\r\n    local rotationDegrees =  obj.getRotation().y\r\n    local steps = 64\r\n    local degrees,sin,cos,toRads = 360/steps, math.sin, math.cos, math.rad\r\n\r\n    for i = 0,steps do\r\n        table.insert(result,{\r\n            x = cos(toRads(degrees*i))*((radius+baseX)*scaleFactor),\r\n            z = MEASURING_RING_Y_OFFSET,\r\n            y = sin(toRads(degrees*i))*((radius+baseZ)*scaleFactor)\r\n        })\r\n    end\r\n\r\n    return result\r\nend\r\n\r\n\r\nfunction getRectangleVectorPoints(radius, sizeX, sizeZ, obj)\r\n    local result = {}\r\n    local scaleFactor = 1/obj.getScale().x\r\n    \r\n    sizeX = sizeX*scaleFactor\r\n    sizeZ = sizeZ*scaleFactor\r\n    radius = radius*scaleFactor\r\n\r\n    local steps = 65\r\n    local degrees,sin,cos,toRads = 360/(steps-1), math.sin, math.cos, math.rad\r\n    local xOffset,zOffset = sizeX,sizeZ\r\n    -- compensate for ignoring vertical line\r\n    table.insert(result,{\r\n        x = (cos(toRads(degrees*0))*radius)+sizeX-0.001,\r\n        y = (sin(toRads(degrees*0))*radius)+sizeZ,\r\n        z = MEASURING_RING_Y_OFFSET\r\n    })\r\n\r\n    for i = 1,steps-1 do\r\n        if i == 16 then\r\n            table.insert(result,{ x= sizeX, y=(radius+sizeZ), z=MEASURING_RING_Y_OFFSET })\r\n            table.insert(result,{ x=-sizeX, y=(radius+sizeZ), z=MEASURING_RING_Y_OFFSET })\r\n            xOffset = -sizeX\r\n        elseif i == 33 then\r\n            table.insert(result,{ x=-radius-sizeX,       y= sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            table.insert(result,{ x=-radius-sizeX-0.001, y=-sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            table.insert(result,{ x=-radius-sizeX,       y=-sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            zOffset = -sizeZ\r\n        elseif i == 49 then\r\n            table.insert(result,{ x=-sizeX, y=-radius-sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            table.insert(result,{ x= sizeX, y=-radius-sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            xOffset = sizeX\r\n        elseif i == 65 then\r\n            table.insert(result,{ x=radius+sizeX,       y=-sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n            table.insert(result,{ x=radius+sizeX-0.001, y= sizeZ, z=MEASURING_RING_Y_OFFSET })\r\n        else\r\n            table.insert(result,{\r\n                x = (cos(toRads(degrees*i))*radius)+xOffset,\r\n                y = (sin(toRads(degrees*i))*radius)+zOffset,\r\n                z = MEASURING_RING_Y_OFFSET\r\n            })\r\n        end\r\n    end\r\n    -- compensate for ignoring vertical line\r\n    table.insert(result,{\r\n        x = (cos(toRads(degrees*0))*radius)+sizeX-0.001,\r\n        y = (sin(toRads(degrees*0))*radius)+sizeZ,\r\n        z = MEASURING_RING_Y_OFFSET\r\n    })\r\n    \r\n    return result\r\nend\n\n\n\n\n--[[ CRUSADE STUFF ]]--\r\n\r\n\r\nfunction showTallyCard(playerColor)\r\n    local agendaManager = getAgendaManager()\r\n\r\n    -- dont do anything if the agenda manager isnt present\r\n    if agendaManager == nil then\r\n        broadcastToColor(\"That unit is not associated with an Agenda Manager!\", playerColor, \"Red\")\r\n        return\r\n    else\r\n        buildAgendas(agendaManager.call(\"getTalliesForUnit\", unitData.uuid))\r\n\r\n        Wait.frames(function ()  -- delay for building agendas\r\n            showCard(\"tallyCard\", playerColor, updateCounters) \r\n        end, 2)\r\n    end\r\nend\r\n\r\nfunction showCrusadeCard(playerColor)\r\n    loadCrusadeCard()\r\n    -- delay to wait for update\r\n    Wait.frames(function () showCard(\"crusadeCard\", playerColor) end, 2)\r\nend\r\n\r\nfunction loadDecodedState(decodedState)\r\n    crusadeCardData = decodedState.crusadeCard\r\nend\r\n\r\nfunction loadDefaultValues()\r\n    crusadeCardData.fields.ccUnitName = unitData.unitDecorativeName\r\nend\r\n\r\nfunction getCrusadeCardSaveData()\r\n    return {\r\n        crusadeCard = crusadeCardData\r\n    }\r\nend\r\n\r\nfunction buildCrusadeUI(guid)\r\n    self.UI.setValue(\"tally-UnitName\", unitData.unitDecorativeName)\r\n    \r\n    self.UI.setAttribute(\"crusadeCardCloseButton\", \"onClick\", guid..\"/hideCard(crusadeCard)\")\r\n    self.UI.setAttribute(\"tallyCardCloseButton\", \"onClick\", guid..\"/hideCard(tallyCard)\")\r\n\r\n    if crusadeCardData.fields.ccUnitName == \"\" then crusadeCardData.fields.ccUnitName = unitData.unitDecorativeName end\r\n\r\n    for counter,val in pairs(crusadeCardData.counters) do\r\n        self.UI.setAttribute(counter..\"Up\", \"onClick\", guid..\"/incrementCounterText(\"..counter..\")\")\r\n        self.UI.setAttribute(counter..\"Down\", \"onClick\", guid..\"/decrementCounterText(\"..counter..\")\")\r\n        self.UI.setValue(counter, val)\r\n    end\r\n\r\n    for id,val in pairs(crusadeCardData.fields) do\r\n        self.UI.setValue(id, val)\r\n        self.UI.setAttribute(id, \"onEndEdit\", guid..\"/updateCrusadeCard()\")\r\n    end\r\n\r\n    for id,val in pairs(crusadeCardData.toggles) do\r\n        self.UI.setAttribute(id, \"isOn\", val)\r\n        self.UI.setAttribute(id, \"onValueChanged\", guid..\"/updateCrusadeCard()\")\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ TALLY CARD FUNCTIONS ]]--\r\n\r\n\r\nfunction modTallyCounter(player, counter, mod)\r\n    local agendaManager = getAgendaManager()\r\n    \r\n    -- dont do anything if the agenda manager isnt present\r\n    if agendaManager == nil then\r\n        broadcastToColor(\"Couldn't find the Agenda Manager!\", playerColor, \"Red\")\r\n        return\r\n    else\r\n        local newValue = agendaManager.call(\"updateTallyForUnit\", {\r\n            unitID = unitData.uuid,\r\n            tally = counter,\r\n            mod = mod\r\n        })\r\n        \r\n        UI.setValue(\"agenda-\"..counter, newValue)\r\n    end\r\nend\r\n\r\n\r\nfunction incrementTallyCounter(player, counter)\r\n    modTallyCounter(player, counter, 1)\r\nend\r\n\r\n\r\nfunction decrementTallyCounter(player, counter)\r\n    modTallyCounter(player, counter, -1)\r\nend\r\n\r\n\r\nfunction buildAgendas(listToBuild)\r\n    if listToBuild ~= nil then\r\n        local tallyString = \"\"\r\n        local height = 40\r\n\r\n        for tally,value in pairs(listToBuild) do\r\n            tallyString = tallyString..interpolate(uiTemplates.agenda, {\r\n                counterName = tally, \r\n                counterID = \"agenda-\"..tally,\r\n                guid = self.getGUID(),\r\n                counterValue = value\r\n            })\r\n\r\n            height = height + 37\r\n        end\r\n\r\n        self.UI.setValue(\"tallyContainer\", tallyString)\r\n        self.UI.setAttribute(\"tallyCard\", \"height\", height)\r\n        return true\r\n    end\r\n    -- generally will only return false if it cant find the Agenda manager or there arent any agendas in the inputs\r\n    return false\r\nend\r\n\r\nfunction getAgendaManager()\r\n    for _,tag in pairs(self.getTags()) do\r\n        local _,_,agendaManagerGUID = tag:find(AGENDA_MANAGER_TAG_PATTERN)\r\n\r\n        if agendaManagerGUID ~= nil then\r\n            return getObjectFromGUID(agendaManagerGUID)\r\n        end\r\n    end\r\n\r\n    return nil\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ CRUSADE CARD UTILITY FUNCTIONS ]]--\r\n\r\n\r\nfunction incrementCounterText(player, counter)\r\n    crusadeCardData.counters[counter] = crusadeCardData.counters[counter] + 1\r\n    UI.setValue(counter, crusadeCardData.counters[counter])\r\nend\r\n\r\n\r\nfunction decrementCounterText(player, counter)\r\n    crusadeCardData.counters[counter] = crusadeCardData.counters[counter] - 1\r\n    UI.setValue(counter, crusadeCardData.counters[counter])\r\nend\r\n\r\n\r\nfunction updateCrusadeCard(player, value, id)\r\n    if crusadeCardData.fields[id] ~= nil then crusadeCardData.fields[id] = value\r\n    else crusadeCardData.toggles[id] = value end\r\nend\r\n\r\n\r\nfunction loadCrusadeCard(fromData)\r\n    if fromData ~= nil then crusadeCardData = fromData end\r\n\r\n    for id,val in pairs(crusadeCardData.fields) do\r\n        self.UI.setValue(id, val)\r\n    end\r\n    for id,val in pairs(crusadeCardData.toggles) do\r\n        self.UI.setAttribute(id, \"isOn\", val)\r\n    end\r\n    for counter,val in pairs(crusadeCardData.counters) do\r\n        self.UI.setValue(counter, val)\r\n    end\r\n\r\n    -- if fromData is provided, that means its a model becoming a leader\r\n    if fromData ~= nil then\r\n        buildCrusadeUI(self.getGUID())\r\n    end\r\nend\n\n\n\n\n-- this needs to be defined after all scripting functions\nscriptingFunctions = {\n\t--[[1]]  function (playerColor) showCard('dataCard', playerColor) end,\n\t--[[2]]  function (playerColor, target) changeModelWoundCount(-1, target) end,\n\t--[[3]]  function (playerColor, target) changeModelWoundCount(1, target) end,\n\t--[[4]]  function (playerColor, target) changeMeasurementCircle(1, target) end,\n\t--[[5]]  function (playerColor, target) changeMeasurementCircle(-1, target) end,\n\t--[[6]]  function (playerColor, target) assignBase(-1, target) end,\n\t--[[7]]  function (playerColor, target) assignBase(1, target) end,\n\t--[[8]]  toggleRectangularMeasuring,\n\t--[[9]]  showCrusadeCard,\n\t--[[10]] showTallyCard\n}"}